# EnigmaVote

EnigmaVote is a privacy-preserving, on-chain survey that uses Zama FHEVM to keep every answer confidential while still
producing verifiable aggregate results. The survey contains five fixed questions about Zama, each with 2-4 choices, and
lets anyone request the public results for a specific question without revealing individual selections.

## Overview

Most surveys trade privacy for convenience. Respondents must trust a centralized server, and the results can be altered
or selectively disclosed. EnigmaVote replaces that trust model with fully homomorphic encryption on-chain so that:

- Individual answers stay encrypted forever.
- Aggregate counts remain encrypted until a question is explicitly revealed.
- The reveal is per-question, not global, preserving least-privilege disclosure.
- Anyone can audit that counts were computed on-chain.

## Problems Solved

- **Privacy leakage**: Traditional surveys expose individual answers or metadata.
- **Centralized manipulation**: A single backend can alter totals or hide results.
- **Lack of verifiability**: Users cannot audit how totals are computed.
- **All-or-nothing disclosure**: Results are often revealed as a whole, instead of question-by-question.

## Advantages

- **Confidential by default**: Answers never appear in plaintext on-chain.
- **Transparent aggregation**: Counts are updated in a public contract, but remain encrypted.
- **Selective reveal**: Results can be made public for one question at a time.
- **On-chain guarantees**: Aggregation rules are enforced by the contract.
- **Simple participation**: One wallet, one answer per question.

## Survey Content

The contract ships with exactly five Zama-focused questions:

1. **How familiar are you with Zama and FHE?**
   - Just getting started
   - Built a small demo
   - Integrating in a product
   - Running in production
2. **Which Zama resource do you rely on most?**
   - Docs
   - Examples on GitHub
   - Community answers
   - Workshops or talks
3. **What excites you most about Zama FHEVM?**
   - Private voting
   - Confidential DeFi
   - User-owned data
   - Compliance-friendly privacy
4. **Where do you plan to deploy first?**
   - Sepolia testnet
   - Mainnet
   - Private chain
5. **What do you need next from Zama?**
   - More tutorials
   - SDK improvements
   - Easier deployments

## How It Works

1. The frontend encrypts the selected option using Zama FHEVM tooling.
2. The encrypted choice plus proof are sent to `submitAnswer`.
3. The contract updates encrypted counters for the chosen question.
4. Anyone can call `requestPublicResults` for one question to make its totals publicly decryptable.
5. The UI fetches and displays the decrypted totals for that specific question.

## Architecture

- **Smart contract**: `contracts/EncryptedSurvey.sol` stores the questions and encrypted counters.
- **Frontend**: `app/` provides a React + Vite interface with RainbowKit for wallet connections.
- **FHEVM gateway**: Used to decrypt publicly-released aggregates, while keeping raw answers private.

## Tech Stack

- **Solidity 0.8.24** with **Zama FHEVM** libraries
- **Hardhat** for compile, tasks, tests, and deployment
- **React + Vite + TypeScript** for the web interface
- **RainbowKit** for wallet onboarding
- **viem** for contract reads
- **ethers** for contract writes

## Smart Contract Details

Key functions and behavior:

- `submitAnswer(questionId, encryptedChoice, inputProof)`: records a single encrypted answer per wallet and question.
- `getQuestion(questionId)`: returns the question prompt and options.
- `getEncryptedCounts(questionId)`: returns the encrypted counters for that question.
- `requestPublicResults(questionId)`: marks a question's counts as publicly decryptable and emits handles.
- Each question accepts 2-4 options, and there are exactly 5 questions in total.

## Frontend Behavior

- Reads are performed with `viem` for efficient queries.
- Writes use `ethers` to send encrypted choices.
- The ABI used by the UI is generated by the contract build and copied from `deployments/sepolia`.
- The UI is configured in code (no environment variables, no local storage, no localhost network).

## Project Structure

```
.
├── app/                # Frontend (React + Vite)
├── contracts/          # Solidity contracts (FHEVM)
├── deploy/             # Deployment scripts
├── deployments/        # Network deployments and ABIs
├── docs/               # Zama integration references
├── tasks/              # Hardhat tasks
├── test/               # Contract tests
└── hardhat.config.ts   # Hardhat configuration
```

## Local Development

1. Install dependencies in the root:

   ```bash
   npm install
   ```

2. Compile contracts:

   ```bash
   npm run compile
   ```

3. Run tests and tasks before any deployment:

   ```bash
   npm run test
   ```

4. (Optional) Run a local FHEVM-ready node for contract-only testing:

   ```bash
   npx hardhat node
   ```

## Deployment

Deployment uses a private key (not a mnemonic). The Hardhat config expects:

- `INFURA_API_KEY`
- `PRIVATE_KEY`

Create a local `.env` file in the project root with those values for Sepolia deployment. Then:

```bash
npx hardhat deploy --network sepolia
```

After deployment:

1. Copy the generated ABI for `EncryptedSurvey` from `deployments/sepolia` into the frontend.
2. Update the frontend contract address in code.

## Usage Flow

- Connect a wallet with RainbowKit.
- Choose answers and submit encrypted selections.
- Verify that your wallet cannot submit the same question twice.
- Request public results for a single question.
- View the decrypted totals for that question only.

## Limitations and Assumptions

- The contract enforces one response per wallet per question, but does not provide proof-of-uniqueness.
- Public result requests expose aggregate counts for the selected question only.
- Privacy depends on correct use of FHEVM encryption and gateway decryption.

## Future Roadmap

- Multi-survey support with dynamic question sets.
- Optional admin-controlled reveal policies and scheduling.
- Per-question access control for sensitive surveys.
- Anti-sybil integrations (attestations or ZK-based uniqueness).
- Improved UX for key handling and encryption feedback.
- Localization and accessibility improvements.
- Analytics views for encrypted participation trends.

## License

BSD-3-Clause-Clear. See `LICENSE`.
